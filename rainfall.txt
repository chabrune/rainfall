level0:
On lance le programme avec gdb
On regarde les jump et les cmp qui permettent de faire des conditions au programme

On voit :
   0x08048ed4 <+20>:    call   0x8049710 <atoi>
   0x08048ed9 <+25>:    cmp    $0x1a7,%eax
On comprend que le programme fait un atoi sur le parametre passe au programme car sinon fait un segmentation fault
Ensuite comparaison entre 423 (0x1a7) et le registre eax
On tente de passer 423 au programme
Et magie on a un shell qui s'ouvre

$ whoami
level1

On est bien passe level1 donc maintenant reste plus qu'a lire le fichier .pass sur le home du level1
$ cat /home/user/level1/.pass

Bingo
.pass : 1fe8a524fa4bec01ca4ea2a869af2a02260d4a7d5fe7e7c24d8617e6dca12d3a

level1:

uname -m || arch
> i686 // 32 bits

La commande affiche depuis ESP vers les adresses plus hautes

Mémoire haute (0xbfffffff)
+------------------------+ 
|    Arguments          |
+------------------------+ ← EBP + 8
|    Adresse retour     |
+------------------------+ ← EBP + 4
|    Ancien EBP         |
+------------------------+ ← EBP (Base Pointer)
|                       |
|    Variables locales  |
|    et buffer          |
|                       |
+------------------------+ ← ESP (Stack Pointer)
Mémoire basse  (0x00000000)


[AAAA...](74) → [ancien EBP] → [addr system] → [ret bidon] → [addr /bin/sh]

(gdb) disas main
Dump of assembler code for function main:
   0x08048480 <+0>:     push   %ebp
   0x08048481 <+1>:     mov    %esp,%ebp
   0x08048483 <+3>:     and    $0xfffffff0,%esp
   0x08048486 <+6>:     sub    $0x50,%esp
   0x08048489 <+9>:     lea    0x10(%esp),%eax
   0x0804848d <+13>:    mov    %eax,(%esp)
=> 0x08048490 <+16>:    call   0x8048340 <gets@plt>
   0x08048495 <+21>:    leave  
   0x08048496 <+22>:    ret 

Points clés

    ESP pointe toujours vers le haut de la stack (adresse la plus basse)
    PUSH : décrémente ESP (va vers le bas)
    POP : incrémente ESP (va vers le haut)
    Les adresses plus grandes sont "en haut"
    Les adresses plus petites sont "en bas"


call est un alias des deux instructions suivantes :
   push EIP
   jmp <adresse de la fonction>



(gdb) x/i 0xb7e454d3    # Examine l'instruction à cette adresse

(gdb) x/wx $ebp+4
0xbffff64c:     0xb7e454d3
(gdb) x/i 0xb7e454d3
   0xb7e454d3 <__libc_start_main+243>:  mov    %eax,(%esp)

/bin/sh
cat /home/.pass2

run : 0x08048444


Premiere technique : 
Modifer ebp+4 qui est le retour du main ?

Deuxieme technique:
break sur gets, modifier eip par l'adresse de run